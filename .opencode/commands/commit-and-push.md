--- 
name: commit-and-push
description: Commits the last piece of work and pushes to the upstream of the current branch
usage: /commit-and-push [commit_message]
parameters:
  - name: commit_message
    type: string 
    required: false
    description: Optional commit message. If not provided, will be auto-generated based on changes.
examples:
  - "/commit-and-push :bug: Fix namespace reference in HTTPRoute template"
  - "/commit-and-push"
  - "/commit-and-push :sparkles: Add new configuration options"
---

# Commit and Push Slash Command Implementation

## Command Logic

This command performs the following steps:

### 1. Check Git Repository Status
- Verify we're in a git repository
- Get current branch information
- Check for upstream configuration

### 2. Analyze Changes
- Detect modified, added, and deleted files
- Calculate statistics (insertions, deletions)
- Determine change categories (features, fixes, docs, etc.)

### 3. Generate Commit Message (if not provided)
- Auto-generate message based on change analysis
- Follow gitmoji conventions
- Include relevant file changes
- Create meaningful commit summary

### 4. Execute Git Operations
- Stage all changes
- Create commit
- Push to upstream
- Provide detailed feedback

## Auto-Generation Algorithm

When no commit message is provided, the command generates one using:

1. **Change Analysis**:
   - Count file types changed (YAML, MD, etc.)
   - Detect patterns (config changes, documentation, bug fixes)
   - Calculate impact (lines changed)

2. **Gitmoji Selection**:
   - `:wrench:` for configuration changes
   - `:sparkles:` for new features
   - `:bug:` for bug fixes
   - `:memo:` for documentation
   - `:recycle:` for refactoring
   - `:arrow_up:` for dependency updates

3. **Message Structure**:
   ```
   :gitmoji: Auto-commit: [summary of changes]
   
   - [File 1]: [change description]
   - [File 2]: [change description]
   - [Statistics: +X -Y files]
   ```

## Implementation

The implementation follows the logic described above. The command is designed to be safe and provide clear feedback at each step of the process.
#!/bin/bash

# Slash Command: commit-and-push
# Auto-generated by opencode from MD specification

set -e  # Exit on error

# Function to auto-generate commit message
generate_commit_message() {
    local files_changed=0
    local insertions=0
    local deletions=0
    local config_changes=0
    local doc_changes=0
    local new_features=0
    local bug_fixes=0
    
    # Get git diff statistics
    if git diff --cached --numstat 2>/dev/null | grep -v "^$" > /tmp/git_stats.txt; then
        while read add del file; do
            files_changed=$((files_changed + 1))
            insertions=$((insertions + add))
            deletions=$((deletions + del))
            
            # Categorize changes by file type/pattern
            if [[ "$file" == *.yaml || "$file" == *.yml ]]; then
                config_changes=$((config_changes + 1))
            elif [[ "$file" == *.md || "$file" == README* ]]; then
                doc_changes=$((doc_changes + 1))
            elif [[ "$file" == *values* || "$file" == *config* ]]; then
                config_changes=$((config_changes + 1))
            elif [[ "$file" == *feature* || "$file" == *new* ]]; then
                new_features=$((new_features + 1))
            elif [[ "$file" == *fix* || "$file" == *bug* ]]; then
                bug_fixes=$((bug_fixes + 1))
            fi
        done < /tmp/git_stats.txt
    fi
    
    # Also check unstaged changes
    if git diff --numstat 2>/dev/null | grep -v "^$" > /tmp/git_unstaged.txt; then
        while read add del file; do
            files_changed=$((files_changed + 1))
            insertions=$((insertions + add))
            deletions=$((deletions + del))
        done < /tmp/git_unstaged.txt
    fi
    
    # Determine gitmoji and message type
    local gitmoji="üîß"  # Default: wrench for config changes
    local message_type="configuration updates"
    
    if [ $new_features -gt 0 ]; then
        gitmoji="‚ú®"  # sparkles for new features
        message_type="new features"
    elif [ $bug_fixes -gt 0 ]; then
        gitmoji="üêõ"  # bug for fixes
        message_type="bug fixes"
    elif [ $doc_changes -gt $config_changes ]; then
        gitmoji="üìù"  # memo for documentation
        message_type="documentation updates"
    fi
    
    # Generate the commit message
    local message="${gitmoji} Auto-commit: ${message_type}"
    
    if [ $files_changed -gt 0 ]; then
        message="${message}\n\n"
        
        # Add specific file details if not too many files
        if [ $files_changed -le 5 ]; then
            message="${message}- Updated ${files_changed} file(s) with ${insertions} insertions, ${deletions} deletions\n"
        else
            message="${message}- Updated ${files_changed} files (${insertions} insertions, ${deletions} deletions)\n"
        fi
        
        # Add change categories
        if [ $config_changes -gt 0 ]; then
            message="${message}- Configuration: ${config_changes} file(s)\n"
        fi
        if [ $doc_changes -gt 0 ]; then
            message="${message}- Documentation: ${doc_changes} file(s)\n"
        fi
    else
        message="${message}\n\n- No file changes detected in diff"
    fi
    
    echo "$message"
}

# Main execution
echo "=== Commit and Push Slash Command ==="
echo

# Check if we're in a git repository
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "‚ùå Error: Not in a git repository"
    exit 1
fi

# Get current branch
CURRENT_BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null)
if [ -z "$CURRENT_BRANCH" ]; then
    echo "‚ùå Error: Not on any branch (detached HEAD)"
    exit 1
fi

echo "üìÅ Repository: $(basename $(git rev-parse --show-toplevel))"
echo "üåø Branch: $CURRENT_BRANCH"

# Check for changes
if git diff --quiet && git diff --cached --quiet; then
    echo "üìù No changes detected to commit"
    exit 0
fi

echo "üîç Changes detected, preparing commit..."
echo

# Use provided commit message or generate one
COMMIT_MESSAGE="${1:-}"
if [ -z "$COMMIT_MESSAGE" ]; then
    echo "ü§ñ Generating commit message automatically..."
    COMMIT_MESSAGE=$(generate_commit_message)
    echo "üìù Generated message:"
    echo "$COMMIT_MESSAGE"
    echo
else
    echo "üìù Using provided commit message:"
    echo "$COMMIT_MESSAGE"
    echo
fi

# Stage all changes
echo "üì¶ Staging changes..."
git add -A
echo "‚úÖ Changes staged successfully"

# Create commit
echo "üíæ Creating commit..."
if git commit -m "$COMMIT_MESSAGE"; then
    echo "‚úÖ Commit created successfully"
else
    echo "‚ùå Error: Failed to create commit"
    exit 1
fi

# Check upstream and push
echo "üîÑ Checking upstream configuration..."
UPSTREAM=$(git rev-parse --abbrev-ref "$CURRENT_BRANCH"@{upstream} 2>/dev/null)

if [ -n "$UPSTREAM" ]; then
    echo "üì° Upstream found: $UPSTREAM"
    echo "üöÄ Pushing changes..."
    if git push; then
        echo "‚úÖ Push successful!"
    else
        echo "‚ùå Error: Push failed"
        exit 1
    fi
else
    echo "‚ö†Ô∏è  No upstream configured for branch $CURRENT_BRANCH"
    echo "üí° To set upstream, run: git push --set-upstream origin $CURRENT_BRANCH"
fi

echo "üéâ Commit and push operation completed!"
